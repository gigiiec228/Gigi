<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰“å°é³¥å¤§å†’éšª - é—œå¡é¸æ“‡ç‰ˆ (æŒ‰éµä¿®æ­£)</title>
    <style>
        :root {
            --primary: #4CAF50;
            --secondary: #2196F3;
            --danger: #ff5252;
            --warning: #FFC107;
            --dark: #333;
            --light: #f5f5f5;
            --glass: rgba(255, 255, 255, 0.9);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'å¾®è»Ÿæ­£é»‘é«”', Arial, sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: var(--dark);
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none; /* iOS Safari */
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* éŠæˆ²ä¸»å®¹å™¨ */
        .main-wrapper {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 90vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* ç•«é¢åˆ‡æ›å®¹å™¨ */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s;
            opacity: 0;
            pointer-events: none;
            z-index: 0;
        }

        .screen.active {
            opacity: 1;
            pointer-events: all;
            z-index: 10;
        }

        /* --- é¦–é  --- */
        h1.title {
            font-size: 3rem;
            color: white;
            text-shadow: 0 4px 10px rgba(0,0,0,0.5);
            margin-bottom: 20px;
            text-align: center;
        }

        .btn-lg {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: white;
            color: var(--primary);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
            touch-action: manipulation; /* æ”¹å–„è§¸æ§å›æ‡‰ */
        }

        .btn-lg:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }

        /* --- é—œå¡é¸æ“‡é¢æ¿ --- */
        .level-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            width: 90%;
            max-width: 600px;
            padding: 20px;
        }

        .level-card {
            background: var(--glass);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
            border: 2px solid transparent;
            touch-action: manipulation;
        }

        .level-card:hover:not(.locked) {
            transform: translateY(-5px);
            border-color: var(--primary);
            background: white;
        }

        .level-card.locked {
            background: rgba(0,0,0,0.5);
            color: #aaa;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .level-num {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .level-stars {
            font-size: 1.5rem;
            color: #ddd;
            margin-top: 5px;
        }

        .level-stars .star {
            color: #ddd;
        }
        .level-stars .star.earned {
            color: var(--warning);
        }

        .lock-icon {
            font-size: 2rem;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }

        .back-btn {
            margin-top: 30px;
            background: transparent;
            border: 2px solid white;
            color: white;
            padding: 10px 30px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1rem;
            touch-action: manipulation;
        }

        /* --- éŠæˆ²ä»‹é¢ --- */
        .game-area {
            position: relative;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #gameCanvas {
            background: #87CEEB;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            cursor: crosshair;
            max-width: 100%;
            max-height: 65vh; /* ç¨å¾®ç¸®å°é«˜åº¦ç•™ç©ºé–“çµ¦æŒ‰éˆ• */
            display: block;
        }

        .hud {
            width: 600px;
            max-width: 95%;
            display: flex;
            justify-content: space-between;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 10px 20px;
            border-radius: 50px;
            margin-bottom: 10px;
            backdrop-filter: blur(5px);
            font-weight: bold;
        }

        /* ä¿®æ­£å¾Œçš„æš«åœæŒ‰éˆ•æ¨£å¼ */
        #pauseExitBtn {
            margin-top: 20px;
            padding: 15px 40px; /* åŠ å¤§é»æ“Šå€åŸŸ */
            font-size: 1.2rem;
            background: rgba(255, 255, 255, 0.2); /* åŠé€æ˜èƒŒæ™¯ */
            border: 2px solid rgba(255, 255, 255, 0.8);
            color: white;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            z-index: 100; /* ç¢ºä¿åœ¨æœ€ä¸Šå±¤ */
            position: relative; /* ç¢ºä¿ z-index ç”Ÿæ•ˆ */
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: background 0.2s;
            touch-action: manipulation;
            backdrop-filter: blur(5px);
        }

        #pauseExitBtn:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.98);
        }

        /* çµç®—æ¨¡æ…‹æ¡† */
        .modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            width: 80%;
            max-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            display: none;
            z-index: 200; /* æ¯”æŒ‰éˆ•é‚„é«˜ */
        }

        .stars-display {
            font-size: 3rem;
            margin: 20px 0;
            color: #ddd;
        }
        .stars-display .star { color: #ddd; display: inline-block; transition: 0.5s; }
        .stars-display .star.earned { color: var(--warning); transform: scale(1.2); text-shadow: 0 0 10px orange; }

        /* å‹•ç•«èˆ‡ç‰¹æ•ˆ */
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-4px, 0, 0); }
            20%, 80% { transform: translate3d(6px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-8px, 0, 0); }
            40%, 60% { transform: translate3d(8px, 0, 0); }
        }

        .floating-text {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            font-size: 1.5rem;
            animation: floatUp 1s forwards;
            z-index: 150; /* æµ®å‹•æ–‡å­—è¦åœ¨æœ€ä¸Šé¢ */
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }

        /* æ‰‹æ©Ÿé©é… */
        @media (max-width: 650px) {
            .level-grid { grid-template-columns: repeat(2, 1fr); }
            h1.title { font-size: 2rem; }
            #gameCanvas { height: 50vh; width: 95vw; }
            #pauseExitBtn {
                width: 80%; /* æ‰‹æ©Ÿç‰ˆæŒ‰éˆ•å¯¬ä¸€é» */
                padding: 15px 0;
                text-align: center;
            }
        }
    </style>
</head>
<body>

    <div class="main-wrapper">
        
        <!-- 1. é¦–é  -->
        <div id="home-screen" class="screen active">
            <h1 class="title">æ‰“å°é³¥å¤§å†’éšª<br><span style="font-size: 1.5rem; color:#FFD700">ç‰¹åˆ¥è¡Œå‹•ç‰ˆ</span></h1>
            <button class="btn-lg" onclick="showLevelSelect()">é–‹å§‹å†’éšª</button>
        </div>

        <!-- 2. é—œå¡é¸æ“‡é¢æ¿ -->
        <div id="level-screen" class="screen">
            <h1 style="color:white; text-shadow: 0 2px 5px rgba(0,0,0,0.5);">é¸æ“‡é—œå¡</h1>
            <div class="level-grid" id="levelGrid">
                <!-- ç”± JS ç”Ÿæˆ -->
            </div>
            <button class="back-btn" onclick="showHome()">è¿”å›ä¸»é¸å–®</button>
        </div>

        <!-- 3. éŠæˆ²ç•«é¢ -->
        <div id="game-screen" class="screen">
            <div class="game-area">
                <div class="hud">
                    <span id="hudLevel">é—œå¡: 1</span>
                    <span id="hudScore">åˆ†æ•¸: 0</span>
                    <span id="hudTimer">30s</span>
                </div>
                <canvas id="gameCanvas" width="600" height="400"></canvas>
                <!-- æš«åœæŒ‰éˆ•æ”¾åœ¨é€™è£¡ï¼Œç¢ºä¿å±¤ç´šé«˜æ–¼ Canvas -->
                <button id="pauseExitBtn" onclick="pauseGame()">æš«åœ / é€€å‡º</button>
            </div>

            <!-- çµç®—å½ˆçª— -->
            <div class="modal" id="resultModal">
                <h2 id="resultTitle">é—œå¡å®Œæˆ!</h2>
                <div class="stars-display" id="resultStars">
                    <span class="star">â˜…</span><span class="star">â˜…</span><span class="star">â˜…</span>
                </div>
                <p id="resultScore">åˆ†æ•¸: 0</p>
                <div style="display:flex; gap:10px; justify-content:center;">
                    <button class="btn-lg" style="padding:10px 20px; font-size:1rem;" onclick="restartLevel()">é‡ç©</button>
                    <button class="btn-lg" style="padding:10px 20px; font-size:1rem; background:#ccc; color:#333;" onclick="showLevelSelect()">é¸é—œ</button>
                </div>
            </div>
        </div>

    </div>

<script>
    // --- éŠæˆ²æ•¸æ“šé…ç½® ---
    const config = {
        width: 600,
        height: 400,
        totalLevels: 3
    };

    const levels = [
        { name: "åˆç´šè¨“ç·´", time: 30, birdSpeed: [1, 2], birdSize: [40, 60], spawnRate: 1200, bombRate: 0.1, stars: [100, 200, 300] },
        { name: "é€²éšæŒ‘æˆ°", time: 30, birdSpeed: [2, 3.5], birdSize: [30, 50], spawnRate: 900, bombRate: 0.2, stars: [150, 250, 350] },
        { name: "å°ˆå®¶è€ƒé©—", time: 30, birdSpeed: [3, 5], birdSize: [25, 40], spawnRate: 600, bombRate: 0.3, stars: [200, 300, 450] }
    ];

    // ç©å®¶é€²åº¦å­˜æª”
    let playerProgress = JSON.parse(localStorage.getItem('birdHunterProgress')) || {
        maxUnlocked: 1,
        levelStars: { 1: 0, 2: 0, 3: 0 }
    };

    // éŠæˆ²ç‹€æ…‹è®Šæ•¸
    let canvas, ctx;
    let currentLevelIdx = 0;
    let score = 0;
    let timeLeft = 0;
    let entities = []; // åŒ…å«é³¥å’Œç‚¸å½ˆ
    let clouds = []; // é›²æœµé™£åˆ—
    let particles = [];
    let gameInterval, spawnInterval;
    let isPlaying = false;
    let audioCtx;

    // --- è²éŸ³ç³»çµ± ---
    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function playTone(freq, type, duration) {
        if (!audioCtx || audioCtx.state === 'suspended') return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    const sounds = {
        shoot: () => { playTone(600, 'triangle', 0.1); },
        hit: () => { playTone(800, 'sine', 0.1); setTimeout(()=>playTone(1200, 'sine', 0.1), 50); },
        bomb: () => { playTone(100, 'sawtooth', 0.5); },
        win: () => { [0, 200, 400].forEach((d, i) => setTimeout(() => playTone(400+i*200, 'square', 0.2), d)); }
    };

    // --- é¡åˆ¥å®šç¾© ---
    class Entity {
        constructor(isBomb, lvlConfig) {
            this.isBomb = isBomb;
            this.size = lvlConfig.birdSize[0] + Math.random() * (lvlConfig.birdSize[1] - lvlConfig.birdSize[0]);
            this.y = Math.random() * (config.height - 100) + 20;
            this.speed = lvlConfig.birdSpeed[0] + Math.random() * (lvlConfig.birdSpeed[1] - lvlConfig.birdSpeed[0]);
            
            // æ–¹å‘
            this.direction = Math.random() > 0.5 ? 1 : -1;
            this.x = this.direction === 1 ? -this.size : config.width + this.size;

            // å¤–è§€
            this.color = isBomb ? '#333' : `hsl(${Math.random() * 360}, 70%, 60%)`;
            this.wingFlap = 0;
            this.dead = false;
        }

        update() {
            this.x += this.speed * this.direction;
            this.wingFlap += 0.3;
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            if (this.direction === -1) ctx.scale(-1, 1);

            if (this.isBomb) {
                // ç‚¸å½ˆå¤–è§€ (é»‘è‰²åœ“çƒ + å°ç«ç´¢)
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.arc(0, 0, this.size/2, 0, Math.PI*2);
                ctx.fill();
                // éª·é«æ¨™èªŒ
                ctx.fillStyle = 'white';
                ctx.font = `${this.size/2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('â˜ ï¸', 0, 2);
                // ç«èŠ±
                if (Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.arc(-5, -this.size/2, 3, 0, Math.PI*2);
                    ctx.fill();
                }
            } else {
                // å°é³¥å¤–è§€
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size/2, this.size/2.5, 0, 0, Math.PI * 2);
                ctx.fill();
                // çœ¼ç›
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(this.size/4, -this.size/6, this.size/6, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(this.size/4 + 2, -this.size/6, this.size/12, 0, Math.PI*2);
                ctx.fill();
                // å˜´å·´
                ctx.fillStyle = '#FFA500';
                ctx.beginPath();
                ctx.moveTo(this.size/2.5, 0);
                ctx.lineTo(this.size/1.5, -this.size/10);
                ctx.lineTo(this.size/2.5, this.size/10);
                ctx.fill();
                // ç¿…è†€
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.ellipse(-this.size/10, this.size/6 + Math.sin(this.wingFlap)*(this.size/5), this.size/2.5, this.size/5, -0.2, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
        }

        checkClick(x, y) {
            const dist = Math.sqrt((this.x - x)**2 + (this.y - y)**2);
            return dist < this.size / 1.5;
        }

        isOffScreen() {
            return (this.direction === 1 && this.x > config.width + this.size) || 
                   (this.direction === -1 && this.x < -this.size);
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.color = color;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 3 + 1;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.life = 1.0;
        }
        update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
        draw(ctx) {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    // --- ç•Œé¢æ§åˆ¶ ---
    const screens = {
        home: document.getElementById('home-screen'),
        level: document.getElementById('level-screen'),
        game: document.getElementById('game-screen')
    };

    function showScreen(name) {
        Object.values(screens).forEach(s => s.classList.remove('active'));
        screens[name].classList.add('active');
    }

    function showHome() { showScreen('home'); }
    function showLevelSelect() { 
        renderLevelGrid(); 
        showScreen('level'); 
    }

    function renderLevelGrid() {
        const grid = document.getElementById('levelGrid');
        grid.innerHTML = '';
        
        levels.forEach((lvl, idx) => {
            const card = document.createElement('div');
            card.className = `level-card ${idx + 1 > playerProgress.maxUnlocked ? 'locked' : ''}`;
            
            if (idx + 1 > playerProgress.maxUnlocked) {
                card.innerHTML = `<div class="lock-icon">ğŸ”’</div>`;
            } else {
                const stars = playerProgress.levelStars[idx + 1];
                let starHtml = '';
                for(let i=0; i<3; i++) {
                    starHtml += `<span class="star ${i < stars ? 'earned' : ''}">â˜…</span>`;
                }
                card.innerHTML = `
                    <div class="level-num">ç¬¬ ${idx+1} é—œ</div>
                    <div style="font-size:0.9rem; color:#666">${lvl.name}</div>
                    <div class="level-stars">${starHtml}</div>
                `;
                card.onclick = () => startGame(idx);
            }
            grid.appendChild(card);
        });
    }

    // --- éŠæˆ²é‚è¼¯ ---
    function init() {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        canvas.addEventListener('mousedown', handleClick);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            handleClick({ clientX: touch.clientX, clientY: touch.clientY });
        });
    }

    function initClouds() {
        clouds = [];
        for (let i = 0; i < 5; i++) {
            clouds.push({
                x: Math.random() * config.width,
                y: Math.random() * 80,
                size: 30 + Math.random() * 50,
                speed: 0.2 + Math.random() * 0.3
            });
        }
    }

    function startGame(levelIdx) {
        currentLevelIdx = levelIdx;
        score = 0;
        timeLeft = levels[levelIdx].time;
        entities = [];
        particles = [];
        initClouds(); // é‡æ–°ç”Ÿæˆé›²æœµ
        isPlaying = true;
        
        showScreen('game');
        updateHUD();

        // å•Ÿå‹•å¾ªç’°
        clearInterval(gameInterval);
        clearInterval(spawnInterval);
        
        gameInterval = setInterval(() => {
            if(!isPlaying) return;
            timeLeft--;
            updateHUD();
            if(timeLeft <= 0) endGame();
        }, 1000);

        const spawnRate = levels[levelIdx].spawnRate;
        spawnInterval = setInterval(() => {
            if(!isPlaying) return;
            const isBomb = Math.random() < levels[levelIdx].bombRate;
            entities.push(new Entity(isBomb, levels[levelIdx]));
        }, spawnRate);

        requestAnimationFrame(gameLoop);
    }

    function handleClick(e) {
        if (!isPlaying) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        let hit = false;
        // å€’åºæª¢æ¸¬ï¼ˆå„ªå…ˆé»åˆ°ä¸Šå±¤çš„ï¼‰
        for (let i = entities.length - 1; i >= 0; i--) {
            const ent = entities[i];
            if (ent.checkClick(x, y)) {
                hit = true;
                if (ent.isBomb) {
                    // é»åˆ°ç‚¸å½ˆ
                    sounds.bomb();
                    score -= 20;
                    createExplosion(ent.x, ent.y, '#ff0000');
                    shakeScreen();
                    showFloatText(x, y, "-20", "red");
                } else {
                    // é»åˆ°é³¥
                    sounds.hit();
                    score += 10;
                    createExplosion(ent.x, ent.y, ent.color);
                    showFloatText(x, y, "+10", "gold");
                }
                entities.splice(i, 1);
                updateHUD();
                break;
            }
        }

        if (!hit) {
            // ç©ºæ§ä¸æ‰£åˆ†äº†ï¼Œä½†å¯ä»¥åŠ å€‹å°éŸ³æ•ˆ
            sounds.shoot();
        }
    }

    function createExplosion(x, y, color) {
        for(let i=0; i<10; i++) particles.push(new Particle(x, y, color));
    }

    function showFloatText(x, y, text, color) {
        const el = document.createElement('div');
        el.className = 'floating-text';
        el.textContent = text;
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.color = color;
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }

    function shakeScreen() {
        document.body.classList.add('shake');
        setTimeout(() => document.body.classList.remove('shake'), 500);
    }

    function updateHUD() {
        document.getElementById('hudScore').textContent = `åˆ†æ•¸: ${score}`;
        document.getElementById('hudTimer').textContent = `${timeLeft}s`;
        document.getElementById('hudLevel').textContent = `ç¬¬ ${currentLevelIdx+1} é—œ`;
    }

    function drawBackground() {
        // å¤©ç©º
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, config.width, config.height);
        
        // é›²æœµ
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        clouds.forEach(cloud => {
            ctx.beginPath();
            ctx.arc(cloud.x, cloud.y, cloud.size * 0.5, 0, Math.PI * 2);
            ctx.arc(cloud.x + cloud.size * 0.4, cloud.y - cloud.size * 0.15, cloud.size * 0.4, 0, Math.PI * 2);
            ctx.arc(cloud.x + cloud.size * 0.8, cloud.y, cloud.size * 0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // ç§»å‹•é›²æœµ
            cloud.x += cloud.speed;
            if (cloud.x > config.width + 50) cloud.x = -50;
        });
        
        // è‰åœ°
        ctx.fillStyle = '#7CFC00';
        ctx.fillRect(0, config.height - 20, config.width, 20);
        // è‰åœ°è£é£¾
        ctx.fillStyle = '#66CD00';
        for(let i=0; i<config.width; i+=40) {
            ctx.beginPath();
            ctx.moveTo(i, config.height - 20);
            ctx.lineTo(i+10, config.height - 30);
            ctx.lineTo(i+20, config.height - 20);
            ctx.fill();
        }
    }

    function gameLoop() {
        if (!isPlaying) return;

        // ç¹ªè£½èƒŒæ™¯ (åŒ…å«é›²æœµ)
        drawBackground();

        // æ›´æ–°èˆ‡ç¹ªè£½å¯¦é«”
        for (let i = entities.length - 1; i >= 0; i--) {
            let ent = entities[i];
            ent.update();
            ent.draw(ctx);
            if (ent.isOffScreen()) {
                entities.splice(i, 1);
            }
        }

        // ç²’å­
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.update();
            p.draw(ctx);
            if (p.life <= 0) particles.splice(i, 1);
        }

        requestAnimationFrame(gameLoop);
    }

    function pauseGame() {
        if(!confirm("ç¢ºå®šè¦æ”¾æ£„æœ¬å±€ä¸¦é€€å‡ºå—ï¼Ÿ")) return;
        endGame(true);
    }

    function endGame(quit = false) {
        isPlaying = false;
        clearInterval(gameInterval);
        clearInterval(spawnInterval);

        const modal = document.getElementById('resultModal');
        const title = document.getElementById('resultTitle');
        const scoreText = document.getElementById('resultScore');
        const starsContainer = document.getElementById('resultStars');
        
        scoreText.textContent = `åˆ†æ•¸: ${score}`;
        
        // è¨ˆç®—æ˜Ÿæ˜Ÿ
        const lvlData = levels[currentLevelIdx];
        let starCount = 0;
        if (score >= lvlData.stars[2]) starCount = 3;
        else if (score >= lvlData.stars[1]) starCount = 2;
        else if (score >= lvlData.stars[0]) starCount = 1;

        if (quit) {
            title.textContent = "å·²é€€å‡º";
            starCount = 0;
        } else {
            title.textContent = starCount > 0 ? "æŒ‘æˆ°æˆåŠŸ!" : "å†æ¥å†å²!";
            sounds.win();
        }

        // æ›´æ–°æ˜Ÿæ˜Ÿé¡¯ç¤º
        const starsDom = starsContainer.querySelectorAll('.star');
        starsDom.forEach((s, i) => {
            s.className = i < starCount ? 'star earned' : 'star';
        });

        // ä¿å­˜é€²åº¦
        if (!quit && starCount > 0) {
            if (starCount > playerProgress.levelStars[currentLevelIdx + 1]) {
                playerProgress.levelStars[currentLevelIdx + 1] = starCount;
            }
            if (currentLevelIdx + 1 < config.totalLevels && playerProgress.maxUnlocked <= currentLevelIdx + 1) {
                playerProgress.maxUnlocked = currentLevelIdx + 2;
            }
            localStorage.setItem('birdHunterProgress', JSON.stringify(playerProgress));
        }

        modal.style.display = 'block';
    }

    function restartLevel() {
        document.getElementById('resultModal').style.display = 'none';
        startGame(currentLevelIdx);
    }

    // åˆå§‹åŒ–
    init();

</script>
</body>
</html>